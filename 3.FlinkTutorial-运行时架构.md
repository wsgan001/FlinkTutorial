### 运行时架构

---

#### 运行时组件

- JobManager

    - 控制应用程序的主进程
    - 接收作业图(JobGraph)、逻辑数据流图(Logical Dataflow Graph)和打包了所有类库和其他资源的jar
    - 将JobGraph转换为物理层面的数据流图叫做执行图(Execution Graph)，包含所有可以并发执行的任务
    - 向资源管理器请求执行任务必要的资源
    - 运行中负责所有需要中央协调的操作比如checkpoint

- TaskManager

    - 每个TaskManager包含了一定数量的Slots
    - Slots数量限制了TaskManager能执行的任务数量
    - 启动后向ResourceManager注册它的Slots
    - JobManager通过向ResourceManager申请，从而使用Slots
    - 执行过程中TaskManager可以跟其他运行同一应用程序的TaskManager交换数据

- ResourceManager

    - 管理集群资源，slots
    - 包含多种ResourceManager，如Yarn、Mesos、K8S以及Standalone部署
    - 当JobManager申请资源时，充足则直接分配，否则向资源提供平台发起会话申请资源

- Dispatcher

    - 提供restful接口，方便任务提交等
    - 一个应用提交执行时，分发器会启动并将应用移交给JobManager
    - 启动WebUI
    - 不是一定存在的，取决于应用提交运行的方式

#### 任务提交流程

    1. 客户端向Dispatcher提交应用
    2. Dispatcher启动并向JobManager提交应用
    3. JobManager向ResourceManager申请slots
    4. TaskManager启动并向ResourceManager注册自己的slots
    5. ResourceManager向TaskManager发出提供slot的指令
    6. TaskManager提供Slots
    7. JobManager提交要在slots中执行的任务
    8. TaskManager间交互数据

#### 任务提交流程(Yarn Per-Job)

    1. Flink Client上传Flink的jar和配置到HDFS
    2. Flink Client提交Job到ResourceManager(Yarn的)
    3. ResourceManager启动ApplicationMaster(包括NodeManager和JobManager)
    4. JobManager向ResourceManager申请资源
    5. JobManager启动NodeManager(TaskManager)


#### 任务调度原理

